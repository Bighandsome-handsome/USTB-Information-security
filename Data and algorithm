1. 寻找中位数
（1）时间限制: 1000 ms内存限制: 5000 KB
（2）问题描述
        某公司的查询系统需要添加一种特殊的查询功能，该公司拜托你进行实现，
        功能定义如下：给定一个长为n的正整数序列T，以及对这个序列进行查询的次数m，
        每次查询的方式是：输入非负整数b，系统能够选择T中从序列下标0到序列下标b之间的子序列（包括下标0和下标b对应的数，下标从0开始），输出对应子序列的中位数。
（3）输入格式
        输入的第1行为两个正整数n和m，
        输入的第2行为长为n的正整数序列T，
        输入的第3行到第m+2行为一个非负整数b，表示查询的子序列范围。
        对于所有测试样例，m和n均小于300000，T中的元素均小于100000。
（4）输出格式
        输出为m行，每行均为一个数，表示当次查询的中位数。
#include <iostream>
#include <queue>
#include <vector>
using namespace std;

int readNum() {
    char ch = getchar();
    while (ch < '0' || ch > '9') ch = getchar();
    int v = 0;
    while (ch >= '0' && ch <= '9') {
        v = v * 10 + ch - '0';
        ch = getchar();
    }
    return v;
}
float A[300000] = { 0 };  // 用来存储每次计算出来的中位数

int main() {
    int n = readNum();  // 读取 n
    int m = readNum();  // 读取 m

    vector<int> T(n);
    for (int i = 0; i < n; i++) {
        T[i] = readNum();  // 读取序列 T
    }

    // 大根堆，存储较小一半的元素
    priority_queue<int> left;
    // 小根堆，存储较大一半的元素
    priority_queue<int, vector<int>, greater<int>> right;

    // 插入 [0, b] 区间的元素时维护堆平衡
    for (int j = 0; j < n; j++) {  // 修正循环边界，避免越界
        int num = T[j];

        // 插入新元素时，维护两个堆的平衡
        if (left.empty() || num <= left.top()) {
            left.push(num);
        }
        else {
            right.push(num);
        }

        // 保证两个堆的大小差不超过 1
        if (left.size() > right.size() + 1) {
            right.push(left.top());
            left.pop();
        }
        else if (right.size() > left.size()) {
            left.push(right.top());
            right.pop();
        }

        // 计算中位数
        if ((j + 1) % 2 == 1) {  // 奇数个数时，中位数是大根堆的根
            A[j] = left.top();
        }
        else {  // 偶数个数时，中位数是两个堆的根的平均值
            A[j] = (left.top() + right.top()) / 2.0;
        }
    }

    // 处理每次查询
    for (int i = 0; i < m; i++) {
        int b = readNum();  // 当前查询的 b 值
        cout << A[b] << endl;  // 注意 b 从 1 开始索引，所以应减去 1
    }

    return 0;  // 正常返回
}
